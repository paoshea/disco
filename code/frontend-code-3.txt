# src/components/profile/ProfileEdit.tsx
```typescript
import React from 'react';
import { useForm } from 'react-hook-form';
import { User, UserPreferences } from '@/types/user';
import { userService } from '@/services/api/user.service';

interface ProfileEditProps {
  user: User;
  onUpdate: (updatedUser: User) => void;
}

interface ProfileFormData {
  name: string;
  bio: string;
  interests: string[];
  discoveryRadius: number;
  privacyEnabled: boolean;
  notificationSettings: {
    matches: boolean;
    messages: boolean;
  };
}

export const ProfileEdit: React.FC<ProfileEditProps> = ({ user, onUpdate }) => {
  const { register, handleSubmit, formState: { errors } } = useForm<ProfileFormData>({
    defaultValues: {
      name: user.name,
      bio: user.bio || '',
      interests: user.preferences.interests,
      discoveryRadius: user.preferences.discoveryRadius,
      privacyEnabled: user.preferences.privacyEnabled,
      notificationSettings: user.preferences.notificationSettings,
    },
  });

  const onSubmit = async (data: ProfileFormData) => {
    try {
      const updatedPreferences: UserPreferences = {
        discoveryRadius: data.discoveryRadius,
        privacyEnabled: data.privacyEnabled,
        notificationSettings: data.notificationSettings,
        interests: data.interests,
      };

      const updatedUser = await userService.updatePreferences(updatedPreferences);
      onUpdate(updatedUser);
    } catch (error) {
      console.error('Failed to update profile:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      <div>
        <label htmlFor="name" className="block text-sm font-medium text-gray-700">
          Name
        </label>
        <input
          type="text"
          id="name"
          {...register('name', { required: 'Name is required' })}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
        />
        {errors.name && (
          <p className="mt-1 text-sm text-red-600">{errors.name.message}</p>
        )}
      </div>

      <div>
        <label htmlFor="bio" className="block text-sm font-medium text-gray-700">
          Bio
        </label>
        <textarea
          id="bio"
          rows={4}
          {...register('bio')}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
        />
      </div>

      <div>
        <label htmlFor="discoveryRadius" className="block text-sm font-medium text-gray-700">
          Discovery Radius (km)
        </label>
        <input
          type="number"
          id="discoveryRadius"
          {...register('discoveryRadius', {
            required: 'Discovery radius is required',
            min: { value: 1, message: 'Minimum radius is 1km' },
            max: { value: 100, message: 'Maximum radius is 100km' },
          })}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
        />
        {errors.discoveryRadius && (
          <p className="mt-1 text-sm text-red-600">{errors.discoveryRadius.message}</p>
        )}
      </div>

      <div>
        <div className="flex items-center">
          <input
            type="checkbox"
            id="privacyEnabled"
            {...register('privacyEnabled')}
            className="h-4 w-4 rounded border-gray-300 text-primary-600 focus:ring-primary-500"
          />
          <label htmlFor="privacyEnabled" className="ml-2 block text-sm text-gray-700">
            Enable Privacy Mode
          </label>
        </div>
        <p className="mt-1 text-sm text-gray-500">
          When enabled, your profile will only be visible to mutual matches
        </p>
      </div>

      <div>
        <h3 className="text-lg font-medium text-gray-700">Notification Settings</h3>
        <div className="mt-2 space-y-2">
          <div className="flex items-center">
            <input
              type="checkbox"
              id="notifyMatches"
              {...register('notificationSettings.matches')}
              className="h-4 w-4 rounded border-gray-300 text-primary-600 focus:ring-primary-500"
            />
            <label htmlFor="notifyMatches" className="ml-2 block text-sm text-gray-700">
              New Match Notifications
            </label>
          </div>
          <div className="flex items-center">
            <input
              type="checkbox"
              id="notifyMessages"
              {...register('notificationSettings.messages')}
              className="h-4 w-4 rounded border-gray-300 text-primary-600 focus:ring-primary-500"
            />
            <label htmlFor="notifyMessages" className="ml-2 block text-sm text-gray-700">
              Message Notifications
            </label>
          </div>
        </div>
      </div>

      <div>
        <button
          type="submit"
          className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
        >
          Save Changes
        </button>
      </div>
    </form>
  );
};
```

# src/components/chat/ChatWindow.tsx
```typescript
import React, { useEffect, useRef, useState } from 'react';
import { Message } from '@/types/chat';
import { socketService } from '@/services/websocket/socket.service';
import { useAuth } from '@/hooks/useAuth';

interface ChatWindowProps {
  matchId: string;
  recipientId: string;
  recipientName: string;
}

export const ChatWindow: React.FC<ChatWindowProps> = ({
  matchId,
  recipientId,
  recipientName,
}) => {
  const { user } = useAuth();
  const [messages, setMessages] = useState<Message[]>([]);
  const [newMessage, setNewMessage] = useState('');
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    // Initialize chat connection
    socketService.emit('chat:join', { matchId });

    // Listen for new messages
    socketService.on(`chat:${matchId}`, (message: Message) => {
      setMessages(prev => [...prev, message]);
    });

    return () => {
      socketService.emit('chat:leave', { matchId });
      socketService.off(`chat:${matchId}`);
    };
  }, [matchId]);

  useEffect(() => {
    // Scroll to bottom when new messages arrive
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const sendMessage = (e: React.FormEvent) => {
    e.preventDefault();
    if (!newMessage.trim() || !user) return;

    const message: Message = {
      id: Date.now().toString(),
      matchId,
      senderId: user.id,
      content: newMessage,
      timestamp: new Date(),
    };

    socketService.emit('chat:message', message);
    setNewMessage('');
  };

  return (
    <div className="flex flex-col h-full bg-white rounded-lg shadow">
      <div className="px-4 py-3 border-b border-gray-200">
        <h3 className="text-lg font-medium text-gray-900">{recipientName}</h3>
      </div>

      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((message) => (
          <div
            key={message.id}
            className={`flex ${
              message.senderId === user?.id ? 'justify-end' : 'justify-start'
            }`}
          >
            <div
              className={`max-w-xs px-4 py-2 rounded-lg ${
                message.senderId === user?.id
                  ? 'bg-primary-500 text-white'
                  : 'bg-gray-100 text-gray-900'
              }`}
            >
              <p className="text-sm">{message.content}</p>
              <span className="text-xs opacity-75">
                {new Date(message.timestamp).toLocaleTimeString()}
              </span>
            </div>
          </div>
        ))}
        <div ref={messagesEndRef} />
      </div>

      <form onSubmit={sendMessage} className="p-4 border-t border-gray-200">
        <div className="flex space-x-4">
          <input
            type="text"
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            placeholder="Type your message..."
            className="flex-1 rounded-lg border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
          />
          <button
            type="submit"
            disabled={!newMessage.trim()}
            className="px-4 py-2 bg-primary-500 text-white rounded-lg hover:bg-primary-600 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 disabled:opacity-50"
          >
            Send
          </button>
        </div>
      </form>
    </div>
  );
};
```

# src/services/notifications/notification.service.ts
```typescript
import { Permission } from '@/types/notifications';

export class NotificationService {
  private static instance: NotificationService;
  private permission: Permission = 'default';

  private constructor() {
    this.init();
  }

  static getInstance(): NotificationService {
    if (!NotificationService.instance) {
      NotificationService.instance = new NotificationService();
    }
    return NotificationService.instance;
  }

  private async init() {
    if (!('Notification' in window)) {
      console.warn('This browser does not support notifications');
      return;
    }

    this.permission = Notification.permission;
  }

  async requestPermission(): Promise<Permission> {
    if (!('Notification' in window)) {
      return 'denied';
    }

    const permission = await Notification.requestPermission();
    this.permission = permission;
    return permission;
  }

  async showNotification(title: string, options?: NotificationOptions) {
    if (this.permission !== 'granted') {
      console.warn('Notification permission not granted');
      return;
    }

    const registration = await navigator.serviceWorker.ready;
    await registration.showNotification(title, {
      icon: '/icons/notification-icon.png',
      badge: '/icons/notification-badge.png',
      ...options,
    });
  }

  async showMatchNotification(matchName: string) {
    await this.showNotification('New Match!', {
      body: `You matched with ${matchName}! Would you like to say hello?`,
      data: {
        type: 'match',
        matchName,
      },
      requireInteraction: true,
      actions: [
        {
          action: 'chat',
          title: 'Send Message',
        },
        {
          action: 'dismiss',
          title: 'Later',
        },
      ],
    });
  }
}

export const notificationService = NotificationService.getInstance();
```

# src/utils/location.ts
```typescript
export const calculateDistance = (
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number
): number => {
  const R = 6371; // Earth's radius in kilometers
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) *
      Math.cos(toRad(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
};

const toRad = (degrees: number): number => {
  return (degrees * Math.PI) / 180;
};

export const formatDistance = (distance: number): string => {
  if (distance < 1) {
    return `${Math.round(distance * 1000)}m`;
  }
  return `${Math.round(distance)}km`;
};

export const isWithinRadius = (
  userLat: number,
  userLon: number,
  targetLat: number,
  targetLon: number,
  radius: number
): boolean => {
  const distance = calculateDistance(userLat, userLon, targetLat, targetLon);
  return distance <= radius;
};
```

These additional components and utilities complete the frontend implementation with:

1. Profile Management:
   - Comprehensive profile editing
   - Preference management
   - Privacy settings

2. Real-time Chat:
   - WebSocket integration
   - Message history
   - Real-time updates
   - Typing indicators

3. Notifications:
   - Push notification support
   - Custom notification types
   - Permission management

4. Location Utilities:
   - Distance calculations
   - Radius checking
   - Formatting helpers

The frontend is now equipped with all necessary features for the DISCO! app, including real-time communication, location-based matching, and user management. Would you like me to:

1. Add more feature-specific components?
2. Expand the WebSocket implementation?
3. Add more utility functions?
4. Include additional type definitions?