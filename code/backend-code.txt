# Core API Service (Go)

# services/core-api/cmd/main.go
```go
package main

import (
    "log"
    "github.com/gin-gonic/gin"
    "disco/internal/config"
    "disco/internal/server"
    "disco/internal/middleware"
)

func main() {
    // Load configuration
    cfg, err := config.Load()
    if err != nil {
        log.Fatalf("Failed to load config: %v", err)
    }

    // Initialize router
    router := gin.Default()
    
    // Setup middleware
    router.Use(middleware.Cors())
    router.Use(middleware.Authentication())
    router.Use(middleware.RateLimiter())

    // Initialize server
    srv := server.New(cfg, router)
    
    // Start server
    if err := srv.Run(); err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }
}
```

# services/core-api/internal/models/user.go
```go
package models

import (
    "time"
    "github.com/google/uuid"
)

type User struct {
    ID             uuid.UUID  `json:"id" gorm:"primaryKey;type:uuid"`
    Email          string     `json:"email" gorm:"unique;not null"`
    HashedPassword string     `json:"-"`
    Name           string     `json:"name"`
    CreatedAt      time.Time  `json:"created_at"`
    UpdatedAt      time.Time  `json:"updated_at"`
    LastLoginAt    *time.Time `json:"last_login_at"`
    Settings       UserSettings `json:"settings" gorm:"embedded"`
}

type UserSettings struct {
    DiscoveryRadius float64 `json:"discovery_radius"`
    PrivacyEnabled  bool    `json:"privacy_enabled"`
    ActiveStatus    string  `json:"active_status"`
}
```

# services/core-api/internal/handlers/user_handler.go
```go
package handlers

import (
    "net/http"
    "github.com/gin-gonic/gin"
    "disco/internal/services"
    "disco/internal/models"
)

type UserHandler struct {
    userService *services.UserService
}

func NewUserHandler(userService *services.UserService) *UserHandler {
    return &UserHandler{userService: userService}
}

func (h *UserHandler) CreateUser(c *gin.Context) {
    var user models.User
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    createdUser, err := h.userService.CreateUser(&user)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusCreated, createdUser)
}
```

# Location Service (Rust)

# services/location-service/src/main.rs
```rust
use actix_web::{web, App, HttpServer};
use tokio;

mod models;
mod services;
mod handlers;
mod config;

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Load configuration
    let config = config::load_config().expect("Failed to load config");

    // Initialize services
    let location_service = services::LocationService::new(&config);
    let app_data = web::Data::new(location_service);

    // Start server
    HttpServer::new(move || {
        App::new()
            .app_data(app_data.clone())
            .service(handlers::location::register_routes())
    })
    .bind(("127.0.0.1", 8081))?
    .run()
    .await
}
```

# services/location-service/src/models/location.rs
```rust
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize)]
pub struct Location {
    pub user_id: Uuid,
    pub latitude: f64,
    pub longitude: f64,
    pub accuracy: f32,
    pub geohash: String,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NearbyRequest {
    pub latitude: f64,
    pub longitude: f64,
    pub radius: f32,
    pub limit: Option<i32>,
}
```

# services/location-service/src/services/location_service.rs
```rust
use crate::models::Location;
use redis::{Client, Commands};
use geohash::encode;

pub struct LocationService {
    redis_client: Client,
}

impl LocationService {
    pub fn new(redis_url: &str) -> Self {
        let client = Client::open(redis_url)
            .expect("Failed to connect to Redis");
        Self { redis_client: client }
    }

    pub async fn update_location(&self, location: Location) -> Result<(), Box<dyn std::error::Error>> {
        let conn = self.redis_client.get_connection()?;
        
        // Generate geohash
        let geohash = encode(location.latitude, location.longitude, 8)
            .map_err(|e| format!("Failed to generate geohash: {}", e))?;

        // Store location in Redis
        let key = format!("location:{}:{}", location.user_id, geohash);
        conn.set_ex(key, location.to_string(), 300)?; // 5 minute TTL

        Ok(())
    }
}
```

# User Management Service (Node.js/NestJS)

# services/user-service/src/main.ts
```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.useGlobalPipes(new ValidationPipe());

  const config = new DocumentBuilder()
    .setTitle('DISCO User Service')
    .setDescription('User management API')
    .setVersion('1.0')
    .addBearerAuth()
    .build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);

  await app.listen(3000);
}
bootstrap();
```

# services/user-service/src/users/user.entity.ts
```typescript
import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  email: string;

  @Column()
  passwordHash: string;

  @Column()
  name: string;

  @Column({ type: 'jsonb' })
  preferences: {
    discoveryRadius: number;
    privacyEnabled: boolean;
    notificationSettings: {
      matches: boolean;
      messages: boolean;
    };
  };

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

# services/user-service/src/users/users.service.ts
```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './user.entity';
import { CreateUserDto } from './dto/create-user.dto';
import { hash } from 'bcrypt';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private usersRepository: Repository<User>,
  ) {}

  async create(createUserDto: CreateUserDto): Promise<User> {
    const user = new User();
    user.email = createUserDto.email;
    user.passwordHash = await hash(createUserDto.password, 10);
    user.name = createUserDto.name;
    user.preferences = createUserDto.preferences;

    return this.usersRepository.save(user);
  }

  async findOne(id: string): Promise<User> {
    return this.usersRepository.findOneBy({ id });
  }
}
```

# Real-time Matching Service (Elixir/Phoenix)

# services/matching-service/lib/disco/application.ex
```elixir
defmodule Disco.Application do
  use Application

  def start(_type, _args) do
    children = [
      DiscoWeb.Endpoint,
      {Phoenix.PubSub, name: Disco.PubSub},
      Disco.Presence,
      Disco.MatchingServer
    ]

    opts = [strategy: :one_for_one, name: Disco.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
```

# services/matching-service/lib/disco/matching/matcher.ex
```elixir
defmodule Disco.Matching.Matcher do
  use GenServer
  alias Disco.Matching.Score

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  def init(_opts) do
    {:ok, %{matches: %{}}}
  end

  def handle_call({:find_matches, user_location}, _from, state) do
    matches = 
      user_location
      |> find_nearby_users()
      |> calculate_scores()
      |> filter_matches()

    {:reply, matches, state}
  end

  defp find_nearby_users(location) do
    Disco.Geo.nearby_users(location)
  end

  defp calculate_scores(nearby_users) do
    nearby_users
    |> Enum.map(fn user ->
      {user, Score.calculate(user)}
    end)
  end

  defp filter_matches(scored_users) do
    scored_users
    |> Enum.filter(fn {_user, score} -> score > 0.7 end)
    |> Enum.sort_by(fn {_user, score} -> score end, :desc)
  end
end
```

# services/matching-service/lib/disco_web/channels/user_socket.ex
```elixir
defmodule DiscoWeb.UserSocket do
  use Phoenix.Socket

  channel "user:*", DiscoWeb.UserChannel

  def connect(%{"token" => token}, socket, _connect_info) do
    case Disco.Auth.verify_token(token) do
      {:ok, user_id} ->
        {:ok, assign(socket, :user_id, user_id)}
      {:error, _reason} ->
        :error
    end
  end

  def id(socket), do: "user_socket:#{socket.assigns.user_id}"
end
```

# Configuration Files

# services/core-api/config/config.yaml
```yaml
server:
  port: 8080
  host: "0.0.0.0"

database:
  host: "localhost"
  port: 5432
  name: "disco_core"
  user: "disco_user"

redis:
  host: "localhost"
  port: 6379

security:
  jwt_secret: "your-secret-key"
  token_expiry: "24h"

services:
  location_service: "http://location-service:8081"
  user_service: "http://user-service:3000"
  matching_service: "http://matching-service:4000"
```

# Docker Configurations

# services/core-api/Dockerfile
```dockerfile
FROM golang:1.21-alpine

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .

RUN go build -o main ./cmd/main.go

EXPOSE 8080

CMD ["./main"]
```

# services/location-service/Dockerfile
```dockerfile
FROM rust:1.70 as builder

WORKDIR /usr/src/app
COPY . .

RUN cargo build --release

FROM debian:buster-slim
COPY --from=builder /usr/src/app/target/release/location-service /usr/local/bin/

EXPOSE 8081

CMD ["location-service"]
```

# services/user-service/Dockerfile
```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

EXPOSE 3000

CMD ["npm", "run", "start:prod"]
```

# services/matching-service/Dockerfile
```dockerfile
FROM elixir:1.14-alpine

WORKDIR /app

COPY mix.exs mix.lock ./
RUN mix deps.get

COPY . .
RUN mix compile

EXPOSE 4000

CMD ["mix", "phx.server"]
```
